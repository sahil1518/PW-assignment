# -*- coding: utf-8 -*-
"""NumpyAssignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TeCrocplHXMa0Yb6aaW-iclNx46ISSUs

Create a NumPy array 'arr' of integers from 0 to 5 and print its data type.
"""

import numpy as np

arr = np.arange(6);
arr

arr.dtype

"""Given a NumPy array 'arr', check if its data type is float64."""

arr = np.array([1,2,3,3.4,5.6,7,8,9])
is_float64 = arr.dtype == np.float64
print("Is data type float64?", is_float64)

"""Create a NumPy array 'arr' with a data type of complex128 containing three complex numbers."""

arr1 = np.array([1,2,3,3+5j,4+6j,+5+2j])
arr1

arr1.dtype

"""Convert an existing NumPy array 'arr' of integers to float32 data type."""

a = np.array([1,2,3,4,5,6,7])
a_float32 = a.astype(np.float32)
a_float32

"""Given a NumPy array 'arr' with float64 data type, convert it to float32 to reduce decimal precision."""

a1 = np.array([1.33433,2.5234,3.53344,4.8879,5.76,6.12,7.90])

a1_float32 = np.finfo(np.float64).precision
a1_float32

"""Write a function array_attributes that takes a NumPy array as input and returns its shape, size, and data type."""

import numpy as np
def array_attributes (arr):
    return arr.shape, arr.size, arr.dtype
arr = np.array([[2,3,4],[5,6,7]])
shape,size,dtype =array_attributes(arr)
print("Shape:", shape)
print("Size:", size)
print("Data type:", dtype)

"""Create a function array_dimension that takes a NumPy array as input and returns its dimensionality."""

def array_dimension(arr):
    dim = arr.ndim
    return dim
arr = np.array([[2, 3, 4], [5, 6, 7]])
dimension = array_dimension(arr)
print("no of dimension:", dimension)

"""Design a function item_size_info that takes a NumPy array as input and returns the item size and the total size in bytes."""

import numpy as np

def item_size_info(arr):
    item_sizes = arr.itemsize
    total_size = arr.nbytes
    return item_sizes, total_size
arr =np.array([[2, 3, 4],[5, 6, 7]])

item_sizes,total_size =item_size_info(arr)

print("item_sizes:",item_sizes,"bytes")
print("total_size:", total_size, "bytes")

"""Design a function shape_stride_relationship that takes a NumPy array as input and returns the shape and strides of the array"""

def  shape_stride_relationship(arr):
     shape = arr.shape
     strides = arr.strides
     return  shape,strides
arr =np.array([[2, 3, 4],[5, 6, 7]])

shape, strides = shape_stride_relationship(arr)

print("shape:", shape)
print("strides:", strides)

"""Create a function create_zeros_array that takes an integer n as input and returns a NumPy array of zeros with n elements."""

def create_zeros_array(n):

  return np.zeros(n)
n = 10
zeros_arrays = create_zeros_array(n)
print("zeros_arrays :" ,zeros_arrays  )

"""Write a function create_ones_matrix that takes integers rows and cols as inputs and generates a 2D NumPy array filled with ones of size rows x cols."""

def create_ones_matrix(rows,cols):
  return np.ones((rows,cols))

rows = 3
cols = 4
ones_matrix = create_ones_matrix(rows,cols)
print("ones_matrix:")
print(ones_matrix)

"""Write a function generate_range_array that takes three integers start, stop, and step as arguments and creates a NumPy array with a range starting from start, ending at stop (exclusive), and with the specified step."""

def generate_range_array(start,stop,step):
    return np.arange(start,stop + step ,step)
    # if you wanted to stop exclusive then add the stop and step


start = 1
stop = 20
step = 2
range_array = generate_range_array(start,stop,step)
print("range_array:",range_array)

"""Design a function generate_linear_space that takes two floats start, stop, and an integer num as arguments and generates a NumPy array with num equally spaced values between start and stop (inclusive)."""

def generate_linear_space(start,stop,num):
  return np.linspace(start,stop,num)
start = 2.0
stop = 26.0
num = 5
linear_space = generate_linear_space(start,stop,num)
print("linear_space:",linear_space)

"""Create a function create_identity_matrix that takes an integer n as input and generates a square identity matrix of size n x n using numpy.eye."""

def  create_identity_matrix(n):
     return np.eye(n)


n = 4
identity_matrix = create_identity_matrix(n)
print("identity_matrix :",identity_matrix)

"""Write a function that takes a Python list and converts it into a NumPy array."""

def convert_to_numpy_array(py_list):
    return np.array(py_list)

py_list = [1,2,3,4,5,6]
numpy_array = convert_to_numpy_array(py_list)
print("numpy_array:",numpy_array)

# Create a NumPy array and demonstrate the use of numpy.view to create a new array object with the same data.
import numpy as np
original_array = np.array([[1,2,3],[4,5,6]])
view_array = original_array.view()
view_array[0,0] = 100

print("Original Array:")
print(original_array)
print("\nView Array:")
print(view_array)

# Write a function that takes two NumPy arrays and concatenates them along a specified axis.


def concatenates_array(arr1, arr2, axis=0):
    return np.concatenate((arr1, arr2), axis=axis)

arr1 = np.array([[1, 2, 3, 4, 5, 6]])
arr2 = np.array([[6, 7, 8, 9, 2, 3]])

concatenates_array_result = concatenates_array(arr1, arr2, axis=0)
print("concatenates_array_result axis 0:")
print(concatenates_array_result)

# Create two NumPy arrays with different shapes and concatenate them
# horizontally using `numpy. concatenate`.

arr1 = np.array([[1, 2] ,[3,8],[4,6]])

arr2 = np.array([[6 ],
                  [7],
                 [9],
                ])

concatenates_array = concatenates_array(arr1, arr2, axis=1)
print("concatenates_array_result axis 0:")
print(concatenates_array)

# Write a function that vertically stacks multiple NumPy arrays given as a list.
import numpy as np

arr1 = np.array([[2,3],[4,5],[6,7]])
arr2 = np.array([[2,5],[8,5],[9,7]])

ver_stacks = np.vstack((arr1,arr2))
print("ver_stacks:")
print(ver_stacks)

# Write a Python function using NumPy to create an array of integers within a specified range (inclusive) with a given step size.
import numpy as np

def create_integer_array(start, stop, step):
    return np.arange(start, stop+1, step,)

integer_array = create_integer_array(0, 10, 2)
print("Array of integers:", integer_array)

# Write a Python function using NumPy to generate an array of 10 equally spaced values between 0 and 1 (inclusive).
import numpy as np

def generate_equally_spaced_values():
    return np.linspace(0, 1, 10)

equally_values = generate_equally_spaced_values()
print("Equally spaced values:", equally_values)

# Write a Python function using NumPy to create an array of 5 logarithmically spaced values between 1 and 1000 (inclusive).
import numpy as np

def create_logarithmically_spaced_values():
    return np.logspace(0, 3, 5)

logarithmically_spaced_values = create_logarithmically_spaced_values()
print("Logarithmically spaced values:", logarithmically_spaced_values)

# Create a Pandas DataFrame using a NumPy array that contains 5 rows and 3 columns, where the values are random integers between 1 and 100.
import numpy as np
import pandas as pd
arr = np.random.randint(1,100, size=(5,3))
df = pd.DataFrame(arr , columns= ['Column1', 'Column2', 'Column3'])
print(df)

# Write a function that takes a Pandas DataFrame and replaces all negative
# values in a specific column with zeros. Use NumPy operations within the Pandas
# DataFrame.

import pandas as pd
import numpy as np

def replace_negatives_with_zero(df, column_name):
    if column_name not in df.columns:
        raise ValueError(f"Column '{column_name}' does not exist in the DataFrame.")

    df[column_name] = np.where(df[column_name] < 0, 0, df[column_name])

    return df
# example

data = {
    'A': [1, -2, 3, -4, 5],
    'B': [-1, 2, -3, 4, -5]
}
df = pd.DataFrame(data)
df = replace_negatives_with_zero(df, 'A')
print(df)

# Access the 3rd element from the given NumPy array.
 # arr = np.array([10, 20, 30, 40, 50])

arr = np.array([10, 20, 30, 40, 50])
third_element = arr[2]
print(third_element)

# Retrieve the element at index (1, 2) from the 2D NumPy array.
#arr_2d = np.array([[1, 2, 3], [4, 5, 6],[7, 8, 9]])

arr_2d = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])
element = arr_2d[1, 2]

print(element)

# Using boolean indexing, extract elements greater than 5 from the given NumPy array arr = np.array([3, 8, 2, 10, 5, 7])

arr = np.array([3, 8, 2, 10, 5, 7])
result = arr[arr > 5]

print(result)

# Perform basic slicing to extract elements from index 2 to 5 (inclusive) from the given NumPy array:
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
result = arr[2:6]
print(result)

# Slice the 2D NumPy array to extract the sub-array [[2, 3], [5, 6]] from the given array:
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

result = arr_2d[1:3, 1:3]

print(result)
result = np.concatenate([arr_2d[1, 1:3], arr_2d[2, 1:3]], axis=0)

print(result)

# Write a NumPy function to extract elements in specific order from a given 2D array based on indices
 # provided in another array
import numpy as np

def extract_elements(arr, indices):
    return arr.flat[indices]

arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
indices = np.array([1, 4, 7])
print(extract_elements(arr, indices))

#  Create a NumPy function that filters elements greater than a threshold from a given 1D array using
 # boolean indexing.
def filter_elements(arr, threshold):
    return arr[arr > threshold]

arr = np.array([1, 2, 3, 4, 5])
threshold = 3
print(filter_elements(arr, threshold))

#  Develop a NumPy function that extracts specific elements from a 3D array using indices provided in three
 # separate arrays for each dimension.
def extract_elements_3d(arr, indices1, indices2, indices3):
    return arr[indices1, indices2, indices3]

arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
indices1 = np.array([0, 1])
indices2 = np.array([1, 0])
indices3 = np.array([0, 1])
print(extract_elements_3d(arr, indices1, indices2, indices3))

#  Write a NumPy function that returns elements from an array where both two conditions are satisfied
 # using boolean indexing.
def filter_elements_both(arr, condition1, condition2):
    return arr[condition1 & condition2]

arr = np.array([1, 2, 3, 4, 5])
condition1 = arr > 2
condition2 = arr < 5
print(filter_elements_both(arr, condition1, condition2))

# Create a NumPy function that extracts elements from a 2D array using row and column indices provided
 # in separate arrays.
import numpy as np
def extract_elements(arr, row_indices, col_indices):

    arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    return arr[row_indices, col_indices]

row_indices = np.array([0, 2])
col_indices = np.array([1, 2])

result = extract_elements(arr, row_indices, col_indices)
print(result)

# given an array arr of shape (3, 3), add a scalar value of 5 to each element using NumPy broadcasting.
def add_scalar(arr, value):
    return arr + value

arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
value = 5
print(add_scalar(arr, value))

#  Consider two arrays arr1 of shape (1, 3) and arr2 of shape (3, 4). Multiply each row of arr2 by the
 # corresponding element in arr1 using NumPy broadcasting.

def multiply_rows(arr1, arr2):
    return arr1[:, np.newaxis] * arr2

arr1 = np.array([1, 2, 3])
arr2 = np.array([[4, 5], [6, 7], [8, 9]])
print(multiply_rows(arr1, arr2))

# Given a 1D array arr1 of shape (1, 4) and a 2D array arr2 of shape (4, 3), add arr1 to each row of arr2 using
# NumPy broadcasting.

import numpy as np

# Given arrays
arr1 = np.array([[1, 2, 3, 4]])
arr2 = np.array([[5, 6, 7], [8, 9, 10], [11, 12, 13], [14, 15, 16]])

arr1_transposed = arr1.T
result = arr1_transposed + arr2
print(result)

#  Consider two arrays arr1 of shape (3, 1) and arr2 of shape (1, 3). Add these arrays using NumPy
# broadcasting.
import numpy as np

arr1 = np.array([[1], [2], [3]])
arr2 = np.array([[4, 5, 6]])

result = arr1 + arr2

print(result)

#  Given arrays arr1 of shape (2, 3) and arr2 of shape (2, 2), perform multiplication using NumPy
 # broadcasting. Handle the shape incompatibility.

arr1 = np.array([[1, 2, 3], [4, 5, 6]])
arr2 = np.array([[7, 8], [9, 10]])

arr2_reshaped = arr2[:, np.newaxis, :]
result = arr1[..., np.newaxis] * arr2_reshaped
print("Result of multiplication with broadcasting:")
print(result)

#  Calculate column wise mean for the given array  arr = np.array([[1, 2, 3], [4, 5, 6]])
arr = np.array([[1, 2, 3], [4, 5, 6]])
column_mean = np.mean(arr, axis=0)
column_mean

# Find maximum value in each row of the given array: arr = np.array([[1, 2, 3], [4, 5, 6]])
 row_max = np.max(arr, axis=1)
row_max

#  For the given array, find indices of maximum value in each column. arr = np.array([[1, 2, 3], [4, 5, 6]])
column_max_indices = np.argmax(arr, axis=0)
column_max_indices

#  For the given array, apply custom function to calculate moving sum along rows. arr = np.array([[1, 2, 3], [4, 5, 6]])
def moving_sum(arr, window_size=2):

    return np.array([np.convolve(row, np.ones(window_size, dtype=int), 'valid') for row in arr])

moving_sum_result = moving_sum(arr)
moving_sum_result

# . In the given array, check if all elements in each column are even. arr = np.array([[2, 4, 6], [3, 5, 7]])
arr = np.array([[2, 4, 6], [3, 5, 7]])

all_even_columns = np.all(arr % 2 == 0, axis=0)
all_even_columns

# Given a NumPy array arr, reshape it into a matrix of dimensions `m` rows and `n` columns. Return the
# reshaped matrix  original_array = np.array([1, 2, 3, 4, 5, 6])
def reshape_array(arr, m, n):
    return arr.reshape(m, n)

original_array = np.array([1, 2, 3, 4, 5, 6])
reshaped_array = reshape_array(original_array, 2, 3)
reshaped_array

# Create a function that takes a matrix as input and returns the flattened array
 # input_matrix = np.array([[1, 2, 3], [4, 5, 6]])

def flatten_matrix(matrix):
    return matrix.flatten()

input_matrix = np.array([[1, 2, 3], [4, 5, 6]])
flattened_array = flatten_matrix(input_matrix)
flattened_array

# Write a function that concatenates two given arrays along a specified axis
# array1 = np.array([[1, 2], [3, 4]])
# array2 = np.array([[5, 6], [7, 8]])
def concatenate_arrays(arr1, arr2, axis=0):
    return np.concatenate((arr1, arr2), axis=axis)

array1 = np.array([[1, 2], [3, 4]])
array2 = np.array([[5, 6], [7, 8]])
concatenated_array = concatenate_arrays(array1, array2, axis=0)
concatenated_array

# Create a function that splits an array into multiple sub-arrays along a specified axis.
# original_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
def split_array(arr, indices, axis=0):
    return np.array_split(arr, indices, axis=axis)

original_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
split_arrays = split_array(original_array, 2, axis=0)

split_arrays

# . Write a function that inserts and then deletes elements from a given array
# at specified indices. %%
# original_array = np.array([1, 2, 3, 4, 5])
# indices_to_insert = [2, 4]
# values_to_insert = [10, 11]
# indices_to_delete = [1, 3]
def insert_and_delete_elements(arr, indices_to_insert, values_to_insert,
                               indices_to_delete):
    arr = np.insert(arr, indices_to_insert, values_to_insert)
    arr = np.delete(arr, indices_to_delete)
    return arr


original_array = np.array([1, 2, 3, 4, 5])
indices_to_insert = [2, 4]
values_to_insert = [10, 11]
indices_to_delete = [1, 3]
modified_array = insert_and_delete_elements(original_array, indices_to_insert,
values_to_insert, indices_to_delete)
modified_array

#  Create a NumPy array `arr1` with random integers and another array `arr2` with integers from 1 to 10.
 # Perform element-wise addition between `arr1` and `arr2`.
arr1 = np.random.randint(1, 100, size=10)
arr2 = np.arange(1, 11)
result_addition = arr1 + arr2
arr1, arr2, result_addition

#Generate a NumPy array `arr1` with sequential integers from 10 to 1 and another array `arr2` with integers
# from 1 to 10. Subtract `arr2` from `arr1` element-wise.
arr1 = np.arange(10, 0, -1)
arr2 = np.arange(1, 11)
result_subtraction = arr1 - arr2
arr1, arr2, result_subtraction

#Create a NumPy array `arr1` with random integers and another array `arr2` with integers from 1 to 5.
#Perform element-wise multiplication between `arr1` and `arr2`.
arr1 = np.random.randint(1, 100, size=5)
arr2 = np.arange(1, 6)
result_multiplication = arr1 * arr2
arr1, arr2, result_multiplication

#  Generate a NumPy array `arr1` with even integers from 2 to 10 and another array `arr2` with integers from 1
 # to 5. Perform element-wise division of `arr1` by `arr2`.
arr1 = np.arange(2, 11, 2)
arr2 = np.arange(1, 6)
result_division = arr1 / arr2
arr1, arr2, result_division

# Create a NumPy array `arr1` with integers from 1 to 5 and another array `arr2` with the same numbers
# reversed. Calculate the exponentiation of `arr1` raised to the power of `arr2` element-wise.
arr1 = np.arange(1, 6)
arr2 = arr1[::-1]
result_exponentiation = arr1 ** arr2
arr1, arr2, result_exponentiation

# Write a function that counts the occurrences of a specific substring within a
# NumPy array of strings. %%  arr = np.array(['hello', 'world', 'hello', 'numpy', 'hello'])
def count_substring(arr, substring):
    return np.char.count(arr, substring)

arr = np.array(['hello', 'world', 'hello', 'numpy', 'hello'])
substring_count = count_substring(arr, 'hello')
substring_count

#  Write a function that extracts uppercase characters from a NumPy array of strings.
#arr = np.array(['Hello', 'World', 'OpenAI', 'GPT'])
# arr = np.array(['Hello', 'World', 'OpenAI', 'GPT'])
import numpy as np
import re

def extract_uppercase(arr):
    result = []
    for string in arr:
        uppercase_chars = "".join(re.findall(r'[A-Z]', string))
        result.append(uppercase_chars)
    return np.array(result)

arr = np.array(['Hello', 'World', 'OpenAI', 'GPT'])
uppercase_characters = extract_uppercase(arr)
print(uppercase_characters)

# Write a function that replaces occurrences of a substring in a NumPy array of strings with a new string.
 # arr = np.array(['apple', 'banana', 'grape', 'pineapple'])
 def replace_substring(arr, old, new):
    return np.char.replace(arr, old, new)


arr = np.array(['apple', 'banana', 'grape', 'pineapple'])
replaced_array = replace_substring(arr, 'apple', 'orange')
replaced_array

#. Write a function that concatenates strings in a NumPy array element-wise  .arr1 = np.array(['Hello', 'World'])
 # arr2 = np.array(['Open', 'AI'])
 def concatenate_strings(arr1, arr2):
    return np.char.add(arr1, arr2)

# Example usage
arr1 = np.array(['Hello', 'World'])
arr2 = np.array(['Open', 'AI'])
concatenated_array = concatenate_strings(arr1, arr2)
concatenated_array

#  Write a function that finds the length of the longest string in a NumPy array.

# arr = np.array(['apple', 'banana', 'grape', 'pineapple'])

def length_of_longest_string(arr):
    return np.max(np.char.str_len(arr))

# Example usage
arr = np.array(['apple', 'banana', 'grape', 'pineapple'])
longest_length = length_of_longest_string(arr)
longest_length

# Create a dataset of 100 random integers between 1 and 1000. Compute the mean, median, variance, and
# standard deviation of the dataset using NumPy's functions.
dataset = np.random.randint(1, 1001, size=100)
mean = np.mean(dataset)
median = np.median(dataset)
variance = np.var(dataset)
std_dev = np.std(dataset)

mean, median, variance, std_dev

#  Generate an array of 50 random numbers between 1 and 100. Find the 25th and 75th percentiles of the
# dataset.
random_numbers = np.random.randint(1, 101, size=50)
percentile_25 = np.percentile(random_numbers, 25)
percentile_75 = np.percentile(random_numbers, 75)

percentile_25, percentile_75

# Create two arrays representing two sets of variables. Compute the correlation coefficient between these
# arrays using NumPy's `corrcoef` function.
array1 = np.random.rand(100)
array2 = np.random.rand(100)
correlation_coefficient = np.corrcoef(array1, array2)

correlation_coefficient

# Create two matrices and perform matrix multiplication using NumPy's `dot` function
 matrix1 = np.random.rand(3, 2)
matrix2 = np.random.rand(2, 3)
matrix_product = np.dot(matrix1, matrix2)

matrix_product

# . Create an array of 50 integers between 10 and 1000. Calculate the 10th, 50th (median), and 90th
# percentiles along with the first and third quartiles.
integers_array = np.random.randint(10, 1001, size=50)
percentile_10 = np.percentile(integers_array, 10)
percentile_50 = np.percentile(integers_array, 50)
percentile_90 = np.percentile(integers_array, 90)
quartile_1 = np.percentile(integers_array, 25)
quartile_3 = np.percentile(integers_array, 75)

percentile_10, percentile_50, percentile_90, quartile_1, quartile_3

#  Create a NumPy array of integers and find the index of a specific element
arr = np.array([10, 20, 30, 40, 50])
index_of_element = np.where(arr == 30)[0][0]

index_of_element

# Generate a random NumPy array and sort it in ascending order.
random_array = np.random.randint(1, 101, size=10)
sorted_array = np.sort(random_array)

sorted_array

#  Filter elements >20  in the given NumPy array. arr = np.array([12, 25, 6, 42, 8, 30])
arr = np.array([12, 25, 6, 42, 8, 30])
filtered_elements = arr[arr > 20]

filtered_elements

# Filter elements which are divisible by 3 from a given NumPy array.
# arr = np.array([1, 5, 8, 12, 15])
arr = np.array([1, 5, 8, 12, 15])
divisible_by_3 = arr[arr % 3 == 0]

divisible_by_3

# Filter elements which are ≥ 20 and ≤ 40 from a given NumPy array.
# arr = np.array([10, 20, 30, 40, 50])
arr = np.array([10, 20, 30, 40, 50])
filtered_elements = arr[(arr >= 20) & (arr <= 40)]

filtered_elements

# For the given NumPy array, check its byte order using the `dtype` attribute byteorder.
# arr = np.array([1, 2, 3])
arr = np.array([1, 2, 3])
byte_order = arr.dtype.byteorder

byte_order

# For the given NumPy array, perform byte swapping in place using `byteswap()`.
# arr = np.array([1, 2, 3], dtype=np.int32)
arr = np.array([1, 2, 3], dtype=np.int32)
arr.byteswap(inplace=True)
arr

# . For the given NumPy array, swap its byte order without modifying the original array using
# `newbyteorder()`. arr = np.array([1, 2, 3], dtype=np.int32)
arr = np.array([1, 2, 3], dtype=np.int32)
swapped_arr = arr.byteswap().newbyteorder()
swapped_arr

# For the given NumPy array and swap its byte order conditionally based on system endianness using
# `newbyteorder()`. arr = np.array([1, 2, 3], dtype=np.int32)
arr = np.array([1, 2, 3], dtype=np.int32)
if arr.dtype.byteorder == '=':  # native byte order
    swapped_arr = arr.byteswap().newbyteorder()
else:
    swapped_arr = arr.copy()
swapped_arr

# For the given NumPy array, check if byte swapping is necessary for the current system using `dtype`
# attribute `byteorder`. arr = np.array([1, 2, 3], dtype=np.int32)
arr = np.array([1, 2, 3], dtype=np.int32)
needs_byteswap = arr.dtype.byteorder not in ('=', '|')
needs_byteswap

#  Create a NumPy array `arr1` with values from 1 to 10. Create a copy of `arr1` named `copy_arr` and modify
# an element in `copy_arr`. Check if modifying `copy_arr` affects `arr1`.
arr1 = np.arange(1, 11)
copy_arr = arr1.copy()
copy_arr[0] = 100
(arr1, copy_arr)

# Create a 2D NumPy array `matrix` of shape (3, 3) with random integers. Extract a slice `view_slice` from
# the matrix. Modify an element in `view_slice` and observe if it changes the original `matrix`.
matrix = np.random.randint(1, 100, size=(3, 3))
view_slice = matrix[1:, 1:]
view_slice[0, 0] = 999
(matrix, view_slice)

# Create a NumPy array `array_a` of shape (4, 3) with sequential integers from 1 to 12. Extract a slice
# `view_b` from `array_a` and broadcast the addition of 5 to view_b. Check if it alters the original `array_a`
array_a = np.arange(1, 13).reshape(4, 3)
view_b = array_a[:, 1:]
view_b += 5
array_a

#  Create a NumPy array `orig_array` of shape (2, 4) with values from 1 to 8. Create a reshaped view
#`reshaped_view` of shape (4, 2) from orig_array. Modify an element in `reshaped_view` and check if it
# reflects changes in the original `orig_array`.
orig_array = np.arange(1, 9).reshape(2, 4)
reshaped_view = orig_array.reshape(4, 2)
reshaped_view[0, 0] = 100
(orig_array, reshaped_view)

#  Create a NumPy array `data` of shape (3, 4) with random integers. Extract a copy `data_copy` of
# elements greater than 5. Modify an element in `data_copy` and verify if it affects the original `data`.
data = np.random.randint(1, 10, size=(3, 4))
data_copy = data[data > 5].copy()
data_copy[0] = 999
(data, data_copy)

# Create two matrices A and B of identical shape containing integers and perform addition and subtraction
# operations between them.
A = np.random.randint(1, 10, size=(3, 3))
B = np.random.randint(1, 10, size=(3, 3))
addition_result = A + B
subtraction_result = A - B
(addition_result, subtraction_result)

# Generate two matrices `C` (3x2) and `D` (2x4) and perform matrix multiplication.
C = np.random.randint(1, 10, size=(3, 2))
D = np.random.randint(1, 10, size=(2, 4))
matrix_multiplication_result = np.dot(C, D)
matrix_multiplication_result

#  Create a matrix `E` and find its transpose.
E = np.random.randint(1, 10, size=(3, 3))
transpose_E = E.T
transpose_E

# Generate a square matrix `F` and compute its determinant.
F = np.random.randint(1, 10, size=(3, 3))
determinant_F = np.linalg.det(F)
determinant_F

#  Create a square matrix `G` and find its inverse.
G = np.random.randint(1, 10, size=(3, 3))
try:
    inverse_G = np.linalg.inv(G)
except np.linalg.LinAlgError:
    inverse_G = None
inverse_G

